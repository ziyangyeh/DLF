from torch import nn
from torch import Tensor
from typing import Tuple, Optional

def drop_path(x: Tensor, keep_prob: float = 1.0, inplace: bool = False) -> Tensor:
    mask_shape: Tuple[int] = (x.shape[0],) + (1,) * (x.ndim - 1)
    # remember tuples have the * operator -> (1,) * 3 = (1,1,1)
    mask: Tensor = x.new_empty(mask_shape).bernoulli_(keep_prob)
    mask.div_(keep_prob)
    if inplace:
        x.mul_(mask)
    else:
        x = x * mask
    return x

class DropPath(nn.Module):
    def __init__(self, p: Optional[float] = 0.5, inplace: bool = False):
        super().__init__()
        self.p = p
        self.inplace = inplace
    def forward(self, x: Tensor) -> Tensor:
        if self.training:
            if self.p:
                if self.p > 0:
                    x += drop_path(x, self.p, self.inplace)
        return x
    def __repr__(self):
        return f"{self.__class__.__name__}(p={self.p})"
